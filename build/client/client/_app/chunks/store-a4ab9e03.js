var J=Object.defineProperty;var w=Object.getOwnPropertySymbols;var K=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable;var x=(n,e,t)=>e in n?J(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,p=(n,e)=>{for(var t in e||(e={}))K.call(e,t)&&x(n,t,e[t]);if(w)for(var t of w(e))U.call(e,t)&&x(n,t,e[t]);return n};import{D as Q,N,O as X}from"./vendor-cf4817b6.js";const Y="Contours2Classification_";function l(n,e=null){const t=Y+n,r=typeof localStorage!="undefined",o=()=>{if(r){const a=localStorage.getItem(t);return a?JSON.parse(a):e}return e},s=a=>{r&&localStorage.setItem(t,JSON.stringify(a))},{subscribe:u,set:d,update:y}=Q(o());return u(a=>s(a)),{subscribe:u,update:y,set:d}}var f;(function(n){n[n.InputLayer=0]="InputLayer",n[n.HiddenLayer1=1]="HiddenLayer1",n[n.HiddenLayer2=2]="HiddenLayer2",n[n.OutputLayer=3]="OutputLayer",n[n.Facilitator=4]="Facilitator"})(f||(f={}));var i=f;class L{static nodesEqual(e,t){return e.layer===t.layer&&e.indexWithinLayer===t.indexWithinLayer}trySetInput(e){if(!this.connectedInputInfo)return!1;for(const[t,r]of this.connectedInputInfo.entries())if(L.nodesEqual(r,e.info))return this.input[t]=e.data[r.indexWithinDataPacket],!0;return!1}getOuput(){if(this.output.includes(void 0))throw new Error("Output contains undefined!");return{info:{layer:this.layer,indexWithinLayer:this.layer},data:this.output}}setOutput(e,t){this.output[e]=t}clear(){var e,t;(e=this.input)==null||e.fill(void 0),(t=this.output)==null||t.fill(void 0)}ready(){return this.input.every(e=>e!==void 0)}constructor(e,t,r,o,s){this.room=e.room,this.name=e.name,this.layer=t.layer,this.indexWithinLayer=t.indexWithinLayer,this.inputSize=r,this.outputSize=o,this.input=new Array(r),this.output=new Array(o),this.connectedInputInfo=s}}var W,v,C,O,m,_,P,g,H,I,$,E,S,b,F,M,G,A,k,q,D,T,j;class h{constructor(){this[W]={nodeCount:1,outputsPerNode:1,contourOuputWidth:1},this[v]=void 0}}W=i.OutputLayer,v=i.Facilitator;class Z extends h{constructor(){super(...arguments);this.capacity=6,this.depth=3,this[C]={nodeCount:3,outputsPerNode:2,contourOuputWidth:2},this[O]={nodeCount:2,outputsPerNode:1,contourOuputWidth:2},this[m]=void 0}}C=i.InputLayer,O=i.HiddenLayer1,m=i.HiddenLayer2;class V extends h{constructor(){super(...arguments);this.capacity=7,this.depth=3,this[_]={nodeCount:4,outputsPerNode:2,contourOuputWidth:2},this[P]={nodeCount:2,outputsPerNode:1,contourOuputWidth:2},this[g]=void 0}}_=i.InputLayer,P=i.HiddenLayer1,g=i.HiddenLayer2;class R extends h{constructor(){super(...arguments);this.capacity=8,this.depth=4,this[H]={nodeCount:4,outputsPerNode:2,contourOuputWidth:2},this[I]={nodeCount:2,outputsPerNode:1,contourOuputWidth:3},this[$]={nodeCount:1,outputsPerNode:1,contourOuputWidth:4}}}H=i.InputLayer,I=i.HiddenLayer1,$=i.HiddenLayer2;class tt extends h{constructor(){super(...arguments);this.capacity=9,this.depth=4,this[E]={nodeCount:4,outputsPerNode:3,contourOuputWidth:3},this[S]={nodeCount:3,outputsPerNode:1,contourOuputWidth:2},this[b]={nodeCount:1,outputsPerNode:1,contourOuputWidth:4}}}E=i.InputLayer,S=i.HiddenLayer1,b=i.HiddenLayer2;class et extends h{constructor(){super(...arguments);this.capacity=10,this.depth=4,this[F]={nodeCount:4,outputsPerNode:4,contourOuputWidth:4},this[M]={nodeCount:4,outputsPerNode:1,contourOuputWidth:2},this[G]={nodeCount:1,outputsPerNode:1,contourOuputWidth:4}}}F=i.InputLayer,M=i.HiddenLayer1,G=i.HiddenLayer2;class rt extends h{constructor(){super(...arguments);this.capacity=11,this.depth=4,this[A]={nodeCount:5,outputsPerNode:4,contourOuputWidth:4},this[k]={nodeCount:4,outputsPerNode:1,contourOuputWidth:2},this[q]={nodeCount:1,outputsPerNode:1,contourOuputWidth:4}}}A=i.InputLayer,k=i.HiddenLayer1,q=i.HiddenLayer2;class ot extends h{constructor(){super(...arguments);this.capacity=12,this.depth=4,this[D]={nodeCount:6,outputsPerNode:4,contourOuputWidth:4},this[T]={nodeCount:4,outputsPerNode:1,contourOuputWidth:2},this[j]={nodeCount:1,outputsPerNode:1,contourOuputWidth:4}}}D=i.InputLayer,T=i.HiddenLayer1,j=i.HiddenLayer2;class nt{constructor(){this.layers=[i.InputLayer,i.HiddenLayer1,i.HiddenLayer2,i.OutputLayer],this.configs={6:new Z,7:new V,8:new R,9:new tt,10:new et,11:new rt,12:new ot}}getConfig(e){if(!(e in this.configs))throw new Error(`Unsupported capacity: ${e}`);return this.configs[e]}getLayerConfigMap(e){const t=new Map;return this.layers.filter(o=>e[o]!==void 0).forEach(o=>t.set(o,e[o])),t}getEmptyGraphMap(e){const t=new Map;return this.layers.filter(o=>e[o]!==void 0).forEach(o=>t.set(o,new Map)),t}getNumberOfActiveNodes(e){let t=0;for(const r of e){const[o,s]=r;t+=s.size}return t}tryAddToFirstEmptyNode(e,t,r){var o,s;for(const u of e){const[d,y]=u,a=(s=(o=t[d])==null?void 0:o.nodeCount)!=null?s:0;for(let c=0;c<a;c++)if(!y.has(c))return y.set(c,r),{success:!0,info:{layer:d,indexWithinLayer:c}}}return{success:!1,info:{layer:-1,indexWithinLayer:-1}}}removeNode(e,t){var r;(r=e.get(t.layer))==null||r.delete(t.indexWithinLayer)}getNodeInfoAtPosition(e,t){let r=0;for(let o=0;o<=this.layers.length-1;o++){const s=this.layers[o],u=e[s];if(u===void 0)continue;const{nodeCount:d}=u,y=r,a=r+=d;if(!(t>=a))return{layer:o,indexWithinLayer:t-y}}throw new Error("Could not identify node position")}getPreviousLayer(e,t){const r=this.layers.indexOf(t.layer);if(r<=0)throw new Error(`No previous layer for layer for ${t.layer}`);for(let o=r-1;o>=0;o--){const s=this.layers[o];if(e[s]!==void 0)return s}throw new Error("Could not identify layer")}getNextLayer(e,t){const r=this.layers.indexOf(t.layer),o=this.layers.length-1;if(r>=o)throw new Error(`No next layer for layer for ${t.layer}`);for(let s=r+1;s<=o;s++){const u=this.layers[s];if(e[u]!==void 0)return u}throw new Error("Could not identify layer")}buildNodeForGraph(e,t,r={name:"defaultName",room:"defaultRoom"}){const o=e[t.layer];if(o===void 0)throw new Error(`No information on node's layer: ${t.layer}`);if(t.indexWithinLayer>=o.nodeCount)throw new Error(`Invalid node (layer: ${t.layer}, index: ${t.indexWithinLayer}) for graph of capacity ${e.capacity}`);let s,u;if(t.layer!==i.InputLayer){const y=this.getPreviousLayer(e,t),a=e[y];if(a===void 0)throw new Error(`No information on previous layer ${y}`);if(!(t.indexWithinLayer<a.outputsPerNode))throw new Error(`Not enough outputs in layer ${y} to connect with node ${t.indexWithinLayer} within layer ${t.layer}`);s=a.nodeCount,u=[...Array(s).keys()].map(c=>{const z={layer:y,indexWithinLayer:c},B={indexWithinDataPacket:t.indexWithinLayer};return p(p({},z),B)})}else s=0,u=void 0;const d=o.outputsPerNode;return new L(r,t,s,d,u)}addToGraph(e,t,r){var s;if(t[r]===void 0)return;const{nodeCount:o}=t[r];for(let u=0;u<o;u++){const d=this.buildNodeForGraph(t,{layer:r,indexWithinLayer:u});e.has(r)?(s=e.get(r))==null||s.push(d):e.set(r,[d])}}buildGraph(e){const t=new Map;return this.layers.filter(r=>e[r]).forEach(r=>this.addToGraph(t,e,r)),t}}const ut=N(new nt),at=N(X());l("room",void 0);l("role",void 0);l("inputs",void 0);export{ut as g,at as s};
